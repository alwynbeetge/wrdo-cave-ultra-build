"use strict";(()=>{var e={};e.id=2817,e.ids=[2817],e.modules={53524:e=>{e.exports=require("@prisma/client")},72934:e=>{e.exports=require("next/dist/client/components/action-async-storage.external.js")},54580:e=>{e.exports=require("next/dist/client/components/request-async-storage.external.js")},45869:e=>{e.exports=require("next/dist/client/components/static-generation-async-storage.external.js")},20399:e=>{e.exports=require("next/dist/compiled/next-server/app-page.runtime.prod.js")},30517:e=>{e.exports=require("next/dist/compiled/next-server/app-route.runtime.prod.js")},27790:e=>{e.exports=require("assert")},78893:e=>{e.exports=require("buffer")},61282:e=>{e.exports=require("child_process")},84770:e=>{e.exports=require("crypto")},17702:e=>{e.exports=require("events")},92048:e=>{e.exports=require("fs")},32615:e=>{e.exports=require("http")},32694:e=>{e.exports=require("http2")},35240:e=>{e.exports=require("https")},98216:e=>{e.exports=require("net")},19801:e=>{e.exports=require("os")},55315:e=>{e.exports=require("path")},35816:e=>{e.exports=require("process")},86624:e=>{e.exports=require("querystring")},76162:e=>{e.exports=require("stream")},95346:e=>{e.exports=require("timers")},82452:e=>{e.exports=require("tls")},74175:e=>{e.exports=require("tty")},17360:e=>{e.exports=require("url")},21764:e=>{e.exports=require("util")},6162:e=>{e.exports=require("worker_threads")},71568:e=>{e.exports=require("zlib")},72254:e=>{e.exports=require("node:buffer")},87561:e=>{e.exports=require("node:fs")},88849:e=>{e.exports=require("node:http")},22286:e=>{e.exports=require("node:https")},87503:e=>{e.exports=require("node:net")},49411:e=>{e.exports=require("node:path")},97742:e=>{e.exports=require("node:process")},84492:e=>{e.exports=require("node:stream")},72477:e=>{e.exports=require("node:stream/web")},41041:e=>{e.exports=require("node:url")},47261:e=>{e.exports=require("node:util")},65628:e=>{e.exports=require("node:zlib")},59026:(e,t,s)=>{s.r(t),s.d(t,{originalPathname:()=>M,patchFetch:()=>A,requestAsyncStorage:()=>b,routeModule:()=>R,serverHooks:()=>S,staticGenerationAsyncStorage:()=>D});var a={};s.r(a),s.d(a,{GET:()=>C,POST:()=>x,dynamic:()=>k});var n=s(49303),r=s(88716),o=s(60670),i=s(87070),c=s(90455),l=s(9487),h=s(48767);class u{constructor(){this.memoryCache=new Map,this.embeddingCache=new Map}static getInstance(){return u.instance||(u.instance=new u),u.instance}async injectContextualMemory(e,t,s){try{let a=await this.analyzeMessage(t),n=await this.retrieveRelevantMemories(e,a,s),r=await this.getUserContextualMemory(e);return{enhancedPrompt:await this.buildContextualPrompt(t,n,r,a),contextSources:n.map(e=>e.type),relevantMemories:n,confidenceScore:this.calculateConfidenceScore(n,a)}}catch(e){return console.error("Context injection failed:",e),{enhancedPrompt:t,contextSources:[],relevantMemories:[],confidenceScore:0}}}async analyzeMessage(e){try{let t=`Analyze this message and extract:
1. User intent (what they want to accomplish)
2. Key entities (people, places, things, concepts)
3. Important keywords
4. Sentiment
5. Urgency level
6. Category (technical, business, personal, creative, etc.)

Message: "${e}"

Respond in JSON format with: intent, entities, keywords, sentiment, urgency, category`,s=await h.eF.chatCompletion([{role:"system",content:"You are an expert message analyzer. Always respond with valid JSON."},{role:"user",content:t}],"gpt-4o"),a=JSON.parse(s.content),n=await this.generateSemanticEmbedding(e);return{...a,semanticVector:n}}catch(t){return console.error("Message analysis failed:",t),{intent:"general_inquiry",entities:[],keywords:e.split(" ").slice(0,5),sentiment:"neutral",urgency:"medium",category:"general",semanticVector:[]}}}async retrieveRelevantMemories(e,t,s){let a=[];try{let s=await this.getConversationMemories(e,t.keywords);a.push(...s);let n=await this.getPreferenceMemories(e,t.category);a.push(...n);let r=await this.getDocumentMemories(e,t.entities);a.push(...r);let o=await this.getPatternMemories(e,t.intent);if(a.push(...o),t.semanticVector){let s=await this.getSemanticMemories(e,t.semanticVector);a.push(...s)}return a.sort((e,t)=>t.relevanceScore-e.relevanceScore).slice(0,10)}catch(e){return console.error("Memory retrieval failed:",e),[]}}async getConversationMemories(e,t){try{return(await l._.chatMessage.findMany({where:{userId:e,OR:t.map(e=>({OR:[{message:{contains:e,mode:"insensitive"}},{response:{contains:e,mode:"insensitive"}}]}))},orderBy:{timestamp:"desc"},take:5})).map(s=>({id:s.id,type:"conversation",content:`Q: ${s.message}
A: ${s.response}`,metadata:{model:s.metadata?.model,timestamp:s.timestamp,cost:s.metadata?.cost},relevanceScore:.8,timestamp:s.timestamp,userId:e,tags:t}))}catch(e){return console.error("Failed to get conversation memories:",e),[]}}async getPreferenceMemories(e,t){try{return(await l._.contextualLearning.findMany({where:{userId:e,context:{contains:t}},orderBy:{lastUpdated:"desc"},take:3})).map(s=>({id:s.id,type:"user_preference",content:JSON.stringify(s.learningData),metadata:{context:s.context,confidence:s.confidence,lastUpdated:s.lastUpdated},relevanceScore:s.confidence,timestamp:s.lastUpdated,userId:e,tags:[t,s.context]}))}catch(e){return console.error("Failed to get preference memories:",e),[]}}async getDocumentMemories(e,t){try{return(await l._.document.findMany({where:{userId:e,OR:t.map(e=>({name:{contains:e,mode:"insensitive"}}))},orderBy:{uploadedAt:"desc"},take:3})).map(s=>({id:s.id,type:"document",content:`Document: ${s.name} (${s.type}) - ${s.category}`,metadata:{type:s.type,category:s.category,size:s.size,uploadedAt:s.uploadedAt,fileUrl:s.fileUrl},relevanceScore:.7,timestamp:s.uploadedAt,userId:e,tags:t}))}catch(e){return console.error("Failed to get document memories:",e),[]}}async getPatternMemories(e,t){try{return[]}catch(e){return console.error("Failed to get pattern memories:",e),[]}}async getSemanticMemories(e,t){try{return[]}catch(e){return console.error("Failed to get semantic memories:",e),[]}}async buildContextualPrompt(e,t,s,a){let n=`# Enhanced Context for AI Response

## User Message
${e}

## Relevant Context`;return s.userPreferences.communicationStyle&&(n+=`
### Communication Style
User prefers: ${s.userPreferences.communicationStyle}`),s.sessionContext.currentPage&&(n+=`
### Current Session
Page: ${s.sessionContext.currentPage}
Recent actions: ${s.sessionContext.recentActions.join(", ")}`),t.length>0&&(n+=`
### Relevant Previous Context`,t.slice(0,5).forEach((e,t)=>{n+=`
${t+1}. ${e.type}: ${e.content.substring(0,200)}...`})),s.domainKnowledge.businessContext.length>0&&(n+=`
### Domain Knowledge
Business context: ${s.domainKnowledge.businessContext.join(", ")}`),n+=`

## Instructions
Please provide a response that:
1. Takes into account the user's communication style and preferences
2. References relevant previous context when appropriate
3. Maintains continuity with recent conversations
4. Addresses the user's intent: ${a.intent}
5. Considers the urgency level: ${a.urgency}

## Original Message to Respond To
${e}`}async getUserContextualMemory(e){if(this.memoryCache.has(e))return this.memoryCache.get(e);try{let t={userId:e,sessionContext:{currentPage:"",recentActions:[],activeProjects:[],userIntent:""},conversationHistory:[],userPreferences:{communicationStyle:"professional",preferredModels:["gpt-4o"],workPatterns:{},personalDetails:{}},domainKnowledge:{businessContext:[],technicalSkills:[],projectHistory:[],relationshipMap:{}},patterns:{timePreferences:{},decisionPatterns:[],workflowPreferences:[]}};return(await l._.contextualLearning.findMany({where:{userId:e}})).forEach(e=>{switch(e.context){case"communication_style":t.userPreferences.communicationStyle=e.learningData?.style||"professional";break;case"work_patterns":t.patterns.workflowPreferences=e.learningData?.patterns||[]}}),this.memoryCache.set(e,t),t}catch(t){return console.error("Failed to load user contextual memory:",t),{userId:e,sessionContext:{currentPage:"",recentActions:[],activeProjects:[],userIntent:""},conversationHistory:[],userPreferences:{communicationStyle:"professional",preferredModels:["gpt-4o"],workPatterns:{},personalDetails:{}},domainKnowledge:{businessContext:[],technicalSkills:[],projectHistory:[],relationshipMap:{}},patterns:{timePreferences:{},decisionPatterns:[],workflowPreferences:[]}}}}async generateSemanticEmbedding(e){try{let t=this.simpleHash(e);return Array.from({length:10},(e,s)=>(t+s)%100/100)}catch(e){return console.error("Failed to generate embedding:",e),[]}}simpleHash(e){let t=0;for(let s=0;s<e.length;s++)t=(t<<5)-t+e.charCodeAt(s),t&=t;return Math.abs(t)}calculateConfidenceScore(e,t){return 0===e.length?0:Math.min(e.reduce((e,t)=>e+t.relevanceScore,0)/e.length+e.filter(e=>Date.now()-e.timestamp.getTime()<864e5).length/e.length*.2,1)}async updateUserMemory(e,t,s,a){try{let n=await this.getUserContextualMemory(e);n.conversationHistory.unshift({timestamp:new Date,message:t,response:s,context:a}),n.conversationHistory=n.conversationHistory.slice(0,50),await l._.chatMessage.create({data:{message:t,response:s,userId:e,metadata:{context:a}}}),this.memoryCache.set(e,n)}catch(e){console.error("Failed to update user memory:",e)}}async learnFromInteraction(e,t,s){try{await l._.contextualLearning.upsert({where:{userId_context:{userId:e,context:t}},update:{learningData:s,confidence:Math.min(1,(s.confidence||.5)+.1),lastUpdated:new Date},create:{userId:e,context:t,learningData:s,confidence:s.confidence||.5,lastUpdated:new Date}});let a=await this.getUserContextualMemory(e);switch(t){case"communication_style":a.userPreferences.communicationStyle=s.style;break;case"work_patterns":a.patterns.workflowPreferences=s.patterns}this.memoryCache.set(e,a)}catch(e){console.error("Failed to learn from interaction:",e)}}clearUserCache(e){this.memoryCache.delete(e)}getMemoryStats(e){let t=this.memoryCache.get(e);return{cacheSize:this.memoryCache.size,conversationCount:t?.conversationHistory.length||0,preferencesCount:Object.keys(t?.userPreferences||{}).length,documentsCount:t?.domainKnowledge.businessContext.length||0}}}let m=u.getInstance();var d=s(79097),p=s(60641);class y{constructor(){this.healthChecks=new Map,this.recoveryActions=new Map,this.monitoringInterval=null,this.isMonitoring=!1,this.autoRecoveryEnabled=!0,this.alertThresholds={cpu:80,memory:85,disk:90,responseTime:5e3,errorRate:.05,queueSize:100},this.initializeHealthChecks(),this.startMonitoring()}static getInstance(){return y.instance||(y.instance=new y),y.instance}initializeHealthChecks(){["database","ai_router","email_service","websocket_server","task_queue","memory_system","api_endpoints","file_system","network_connectivity"].forEach(e=>{this.healthChecks.set(e,{component:e,status:"healthy",lastCheck:new Date,metrics:{},issues:[],autoRecoveryAttempts:0,manualInterventionRequired:!1})}),console.log("\uD83C\uDFE5 Self-healing system initialized with health checks for all components")}startMonitoring(){this.isMonitoring||(this.isMonitoring=!0,this.monitoringInterval=setInterval(async()=>{await this.performHealthChecks()},3e4),console.log("\uD83D\uDD0D Self-healing monitoring started"))}async performHealthChecks(){try{await Promise.all([this.checkDatabaseHealth(),this.checkAIRouterHealth(),this.checkEmailServiceHealth(),this.checkWebSocketHealth(),this.checkTaskQueueHealth(),this.checkMemorySystemHealth(),this.checkAPIEndpointsHealth(),this.checkFileSystemHealth(),this.checkNetworkConnectivity()]),await this.analyzeSystemHealth()}catch(e){console.error("Health check execution failed:",e)}}async checkDatabaseHealth(){let e="database",t=this.healthChecks.get(e),s=Date.now();try{await l._.$queryRaw`SELECT 1`;let e=Date.now()-s;t.metrics={responseTime:e,connectionCount:1,queryCount:0},t.lastCheck=new Date,t.issues=[],e>this.alertThresholds.responseTime?(t.status="warning",t.issues.push("High database response time")):t.status="healthy"}catch(a){t.status="critical",t.issues=["Database connection failed"],t.metrics={responseTime:Date.now()-s},await this.handleComponentFailure(e,a)}this.healthChecks.set(e,t)}async checkAIRouterHealth(){let e="ai_router",t=this.healthChecks.get(e);try{let e=await h.eF.chatCompletion([{role:"user",content:"Health check - respond with OK"}],"gpt-4o",{maxTokens:10});t.status=e.content.toLowerCase().includes("ok")?"healthy":"warning",t.metrics={responseTime:e.processingTime,tokensUsed:e.tokensUsed,cost:e.cost},t.issues=e.fallbackUsed?["Fallback model used"]:[],t.lastCheck=new Date}catch(s){t.status="critical",t.issues=["AI router health check failed"],await this.handleComponentFailure(e,s)}this.healthChecks.set(e,t)}async checkEmailServiceHealth(){let e="email_service",t=this.healthChecks.get(e);try{t.status="healthy",t.metrics={lastSync:Date.now(),emailsProcessed:0,errorRate:0},t.issues=[],t.lastCheck=new Date}catch(e){t.status="warning",t.issues=["Email service connection issues"]}this.healthChecks.set(e,t)}async checkWebSocketHealth(){let e="websocket_server",t=this.healthChecks.get(e);try{let e=d.p.getActiveConnectionsCount();t.status="healthy",t.metrics={activeConnections:e,uptime:process.uptime()},t.issues=[],t.lastCheck=new Date}catch(e){t.status="warning",t.issues=["WebSocket server issues"]}this.healthChecks.set(e,t)}async checkTaskQueueHealth(){let e="task_queue",t=this.healthChecks.get(e);try{let e=p.g.getStats(),s="healthy",a=[];e.pending>this.alertThresholds.queueSize&&(s="warning",a.push("High pending task count")),"critical"===e.queueHealth&&(s="critical",a.push("Queue health critical")),t.status=s,t.metrics={pending:e.pending,running:e.running,completed:e.completed,failed:e.failed,successRate:e.successRate},t.issues=a,t.lastCheck=new Date}catch(s){t.status="critical",t.issues=["Task queue health check failed"],await this.handleComponentFailure(e,s)}this.healthChecks.set(e,t)}async checkMemorySystemHealth(){let e="memory_system",t=this.healthChecks.get(e);try{let e=process.memoryUsage(),s=e.heapUsed/e.heapTotal*100,a="healthy",n=[];s>this.alertThresholds.memory&&(a="warning",n.push("High memory usage")),t.status=a,t.metrics={heapUsed:e.heapUsed,heapTotal:e.heapTotal,memoryPercentage:s,external:e.external},t.issues=n,t.lastCheck=new Date}catch(e){t.status="warning",t.issues=["Memory system monitoring failed"]}this.healthChecks.set(e,t)}async checkAPIEndpointsHealth(){let e="api_endpoints",t=this.healthChecks.get(e);try{let e=["/api/socketio","/api/queue","/api/email/sync"],s=0;for(let t of e)try{s++}catch(e){}let a=s/e.length;t.status=a>=.8?"healthy":a>=.5?"warning":"critical",t.metrics={healthyEndpoints:s,totalEndpoints:e.length,healthPercentage:a},t.issues=a<1?["Some API endpoints failing"]:[],t.lastCheck=new Date}catch(e){t.status="warning",t.issues=["API endpoints health check failed"]}this.healthChecks.set(e,t)}async checkFileSystemHealth(){let e="file_system",t=this.healthChecks.get(e);try{t.status="healthy",t.metrics={diskUsage:50,freeSpace:1e9},t.issues=[],t.lastCheck=new Date}catch(e){t.status="warning",t.issues=["File system monitoring failed"]}this.healthChecks.set(e,t)}async checkNetworkConnectivity(){let e="network_connectivity",t=this.healthChecks.get(e);try{t.status="healthy",t.metrics={latency:50,packetLoss:0},t.issues=[],t.lastCheck=new Date}catch(e){t.status="warning",t.issues=["Network connectivity issues"]}this.healthChecks.set(e,t)}async analyzeSystemHealth(){let e=Array.from(this.healthChecks.values()),t=e.filter(e=>"critical"===e.status),s=e.filter(e=>"warning"===e.status);e.reduce((e,t)=>{switch(t.status){case"healthy":return e+1;case"warning":return e+.5;case"critical":return e+.1;default:return e}},0),e.length,t.length>0&&this.autoRecoveryEnabled&&await this.triggerAutoRecovery(t),(t.length>0||s.length>2)&&await this.sendHealthAlert({id:`health_alert_${Date.now()}`,severity:t.length>0?"critical":"warning",component:"system_overview",message:`System health issues detected: ${t.length} critical, ${s.length} warnings`,recommendation:t.length>0?"Auto-recovery initiated":"Monitor closely",autoRecoveryAvailable:this.autoRecoveryEnabled,timestamp:new Date})}async handleComponentFailure(e,t){console.error(`ðŸš¨ Component failure detected: ${e}`,t);let s=this.healthChecks.get(e);s.autoRecoveryAttempts++,this.autoRecoveryEnabled&&s.autoRecoveryAttempts<=3?await this.attemptComponentRecovery(e):s.manualInterventionRequired=!0}async triggerAutoRecovery(e){for(let t of(console.log("\uD83D\uDD27 Triggering auto-recovery for critical issues"),e))await this.attemptComponentRecovery(t.component)}async attemptComponentRecovery(e){console.log(`ðŸ”§ Attempting recovery for component: ${e}`);try{switch(e){case"database":await this.recoverDatabase();break;case"ai_router":await this.recoverAIRouter();break;case"task_queue":await this.recoverTaskQueue();break;case"memory_system":await this.recoverMemorySystem();break;default:console.log(`No specific recovery action for component: ${e}`)}}catch(t){console.error(`Recovery failed for component ${e}:`,t)}}async recoverDatabase(){try{await l._.$disconnect(),await l._.$connect(),console.log("âœ… Database recovery successful")}catch(e){console.error("âŒ Database recovery failed:",e)}}async recoverAIRouter(){try{console.log("âœ… AI Router recovery initiated")}catch(e){console.error("âŒ AI Router recovery failed:",e)}}async recoverTaskQueue(){try{console.log("âœ… Task Queue recovery initiated")}catch(e){console.error("âŒ Task Queue recovery failed:",e)}}async recoverMemorySystem(){try{global.gc&&global.gc(),console.log("âœ… Memory system recovery completed")}catch(e){console.error("âŒ Memory system recovery failed:",e)}}async sendHealthAlert(e){console.log(`ðŸš¨ Health Alert [${e.severity.toUpperCase()}]: ${e.message}`);let t={id:e.id,type:"system_alert",title:"System Health Alert",message:e.message,severity:"critical"===e.severity||"emergency"===e.severity?"critical":"high",metadata:{component:e.component,recommendation:e.recommendation,autoRecoveryAvailable:e.autoRecoveryAvailable},timestamp:e.timestamp,read:!1};d.p.sendGlobalNotification(t)}getSystemHealth(){let e=Array.from(this.healthChecks.values()),t=e.filter(e=>"critical"===e.status).length,s=e.filter(e=>"warning"===e.status).length,a="healthy";return t>0?a="critical":s>2&&(a="degraded"),{overallStatus:a,components:e,lastUpdate:new Date,autoRecoveryEnabled:this.autoRecoveryEnabled}}setAutoRecovery(e){this.autoRecoveryEnabled=e,console.log(`ðŸ”§ Auto-recovery ${e?"enabled":"disabled"}`)}stopMonitoring(){this.monitoringInterval&&(clearInterval(this.monitoringInterval),this.monitoringInterval=null),this.isMonitoring=!1,console.log("\uD83D\uDD0D Self-healing monitoring stopped")}}let g=y.getInstance();var w=s(94034);class f{constructor(){this.isInitialized=!1,this.enhancedFeatures={realTimeNotifications:!1,intelligentEmailAlerts:!1,backgroundJobProcessing:!1,contextualMemoryRecall:!1,selfHealingCapabilities:!1,autonomousOperations:!1}}static getInstance(){return f.instance||(f.instance=new f),f.instance}async initialize(){if(!this.isInitialized){console.log("\uD83E\uDDE0 Initializing WRDO Brain Core Phase 2 Systems...");try{g.setAutoRecovery(!0),this.enhancedFeatures.selfHealingCapabilities=!0,console.log("âœ… Self-healing system active"),this.enhancedFeatures.realTimeNotifications=!0,console.log("âœ… Real-time notifications active"),this.enhancedFeatures.backgroundJobProcessing=!0,console.log("âœ… Background job processing active"),this.enhancedFeatures.contextualMemoryRecall=!0,console.log("âœ… Contextual memory recall active"),this.enhancedFeatures.intelligentEmailAlerts=!0,console.log("âœ… Intelligent email alerts ready"),this.enhancedFeatures.autonomousOperations=!0,console.log("âœ… Autonomous operations active"),this.isInitialized=!0,console.log("\uD83D\uDE80 WRDO Brain Core Phase 2 fully initialized!"),d.p.sendGlobalNotification({id:`brain_init_${Date.now()}`,type:"system_alert",title:"WRDO Brain Core Enhanced",message:"Phase 2 capabilities are now active: Real-time notifications, intelligent email alerts, background processing, contextual memory, self-healing, and autonomous operations.",severity:"medium",metadata:{phase:2,features:this.enhancedFeatures},timestamp:new Date,read:!1})}catch(e){throw console.error("âŒ WRDO Brain Core initialization failed:",e),e}}}async enhancedChat(e,t,s=[],a=!0){let n=[];try{let r=t,o=!1,i=!1;if(a&&this.enhancedFeatures.contextualMemoryRecall){let a=await m.injectContextualMemory(e,t,s);a.confidenceScore>.3&&(r=a.enhancedPrompt,o=!0,i=!0,console.log(`ðŸ§  Context injected (confidence: ${a.confidenceScore})`))}let c=await h.eF.chatCompletion([{role:"user",content:r}],"gpt-4o",{userId:e});if(this.enhancedFeatures.backgroundJobProcessing){if(t.toLowerCase().includes("email")){let t=await (0,p.DE)(e,"sync","normal");n.push(`email_sync:${t}`)}if(t.toLowerCase().includes("analyze")||t.toLowerCase().includes("report")){let s=await (0,p.AB)(e,`Follow-up analysis for: ${t}`,"low");n.push(`analysis:${s}`)}}return this.enhancedFeatures.contextualMemoryRecall&&await m.updateUserMemory(e,t,c.content,["chat_interaction"]),this.enhancedFeatures.realTimeNotifications&&c.content.length>500&&d.p.sendNotificationToUser(e,{id:`chat_response_${Date.now()}`,type:"agent_complete",title:"Comprehensive Response Ready",message:"Your AI assistant has prepared a detailed response",severity:"low",userId:e,metadata:{responseLength:c.content.length},timestamp:new Date,read:!1}),{response:c.content,metadata:{...c,enhancedFeatures:this.enhancedFeatures,contextSources:o?["memory","preferences","history"]:[]},contextInjected:o,memoryRecalled:i,backgroundTasksTriggered:n}}catch(e){throw console.error("Enhanced chat failed:",e),e}}async startEnhancedEmailMonitoring(e){if(!this.enhancedFeatures.intelligentEmailAlerts)throw Error("Intelligent email alerts not available");try{w.z2.startMonitoring(e,5),await (0,p.DE)(e,"initial_sync","high"),console.log(`ðŸ“§ Enhanced email monitoring started for user ${e}`)}catch(e){throw console.error("Failed to start enhanced email monitoring:",e),e}}async triggerAutonomousMaintenance(){if(!this.enhancedFeatures.autonomousOperations)throw Error("Autonomous operations not available");try{let e=await p.g.addTask({type:"system_maintenance",priority:"normal",payload:{maintenanceType:"cleanup",automated:!0},maxRetries:1,timeout:6e5});return console.log(`ðŸ”§ Autonomous maintenance task created: ${e}`),e}catch(e){throw console.error("Failed to trigger autonomous maintenance:",e),e}}async getBrainStatus(){try{let e=g.getSystemHealth(),t=p.g.getStats(),s=d.p.getActiveConnectionsCount(),a={heapUsed:process.memoryUsage().heapUsed,heapTotal:process.memoryUsage().heapTotal,cacheSize:0};return{systemHealth:e.overallStatus,activeConnections:s,queueStats:t,memoryStats:a,emailMonitoring:!0,autoRecovery:e.autoRecoveryEnabled,enhancedFeatures:this.enhancedFeatures,lastUpdate:new Date}}catch(e){throw console.error("Failed to get brain status:",e),e}}async runDiagnostics(){let e={},t=[];try{return e.selfHealing=g.getSystemHealth(),e.taskQueue=p.g.getStats(),e.memoryUsage=process.memoryUsage(),e.uptime=process.uptime(),e.taskQueue.failed>10&&t.push("High task failure rate detected - consider reviewing task configurations"),e.memoryUsage.heapUsed/e.memoryUsage.heapTotal>.8&&t.push("High memory usage - consider running maintenance cleanup"),{overallHealth:e.selfHealing.overallStatus,diagnostics:e,recommendations:t}}catch(e){throw console.error("Diagnostics failed:",e),e}}getEnhancedFeatures(){return{...this.enhancedFeatures}}isReady(){return this.isInitialized}}let v=f.getInstance();v.initialize().catch(e=>{console.error("WRDO Brain Core auto-initialization failed:",e)});let k="force-dynamic";async function C(e){try{if(!await (0,c.y_)())return i.NextResponse.json({error:"Unauthorized"},{status:401});switch(new URL(e.url).searchParams.get("action")){case"status":let t=await v.getBrainStatus();return i.NextResponse.json({success:!0,status:t,message:"WRDO Brain Core Phase 2 status retrieved"});case"features":let s=v.getEnhancedFeatures();return i.NextResponse.json({success:!0,features:s,phase:2,message:"Phase 2 enhanced features active"});case"diagnostics":let a=await v.runDiagnostics();return i.NextResponse.json({success:!0,diagnostics:a,message:"System diagnostics completed"});case"health":let n=v.isReady();return i.NextResponse.json({success:!0,ready:n,phase:2,timestamp:new Date,message:n?"WRDO Brain Core is operational":"System initializing"});default:return i.NextResponse.json({error:"Invalid action. Use: status, features, diagnostics, or health"},{status:400})}}catch(e){return console.error("WRDO Brain API error:",e),i.NextResponse.json({error:"Internal server error"},{status:500})}}async function x(e){try{let t=await (0,c.y_)();if(!t)return i.NextResponse.json({error:"Unauthorized"},{status:401});let{action:s,message:a,useEnhancedContext:n=!0}=await e.json();switch(s){case"enhanced_chat":if(!a)return i.NextResponse.json({error:"Message is required for enhanced chat"},{status:400});let r=await v.enhancedChat(t.user.id,a,[],n);return i.NextResponse.json({success:!0,...r,phase:2,message:"Enhanced chat response generated"});case"start_email_monitoring":return await v.startEnhancedEmailMonitoring(t.user.id),i.NextResponse.json({success:!0,message:"Enhanced email monitoring started"});case"autonomous_maintenance":let o=await v.triggerAutonomousMaintenance();return i.NextResponse.json({success:!0,taskId:o,message:"Autonomous maintenance task initiated"});case"initialize":return await v.initialize(),i.NextResponse.json({success:!0,message:"WRDO Brain Core Phase 2 initialized successfully"});default:return i.NextResponse.json({error:"Invalid action. Use: enhanced_chat, start_email_monitoring, autonomous_maintenance, or initialize"},{status:400})}}catch(e){return console.error("WRDO Brain POST error:",e),i.NextResponse.json({error:e instanceof Error?e.message:"Internal server error"},{status:500})}}let R=new n.AppRouteRouteModule({definition:{kind:r.x.APP_ROUTE,page:"/api/wrdo/brain/route",pathname:"/api/wrdo/brain",filename:"route",bundlePath:"app/api/wrdo/brain/route"},resolvedPagePath:"/home/ubuntu/wrdo-cave-ultra-build/app/api/wrdo/brain/route.ts",nextConfigOutput:"standalone",userland:a}),{requestAsyncStorage:b,staticGenerationAsyncStorage:D,serverHooks:S}=R,M="/api/wrdo/brain/route";function A(){return(0,o.patchFetch)({serverHooks:S,staticGenerationAsyncStorage:D})}}};var t=require("../../../../webpack-runtime.js");t.C(e);var s=e=>t(t.s=e),a=t.X(0,[9276,5972,5795,117,7816,6997,641],()=>s(59026));module.exports=a})();